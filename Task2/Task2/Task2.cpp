// Task2.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include "pch.h"
#include <iostream>
#include <vector>

int main()
{
	int n = 0;
	int m = 0;
	int min = 30; // понятно? да, только значе
	// ри я наверняка должны быть больше да
	// да, поэтому иногда делают максимально возможное, что-то типа INT_MAX, это надо гуглить, я уже не помню, как оно задается
	// но у тебя дни месяца, по сути, максимальная разница это 30 согласен? Нет, с чего это месяца
	// хм
	// ну может да
	// тогла ок, можно поступить так, для min и max задать начальные занчения равные разнице перовго и второго чисекл, но только тебе нужно проверять, что введено более одного числа
	// короче на данный момент использовать 1000000 это ок, но ты прав
	// давай запустим
	// ой
	// ответ 0 1 что неправильно, у нас не может быть 0 согалсен? ну да
	// ща поправим

	int max = 0;
	int k = 0;

	std::cin >> n >> m;

	std::vector <int> a(n);
	std::vector <int> b(m);

	for (int i = 0; i < n; i++) {
		std::cin >> a[i];
	}

	for (int i = 0; i < m; i++) {
		std::cin >> b[i];
	} // реши a = [1, 4, 5, 7] b = [1, 2, 4, 8] ответ? min = 1 max = 4 в плане? смотри, я так понимаю ответ должен быть res = [3, 2, 1, нет ответа] типа 
	// для 1 дня ближ солнце 4 числа и 1, если тот же день не учитывается, то 4 - 1 = 3
	// аналогично для 2 дня ближ 4 день то есть 4 - 2 = 2
	// для 4 дня ближ 5 день, то есть 5 - 4 = 1
	// для 8 дня нет ответа, ну мы не будем вводить такие данные
	// понял? да, все правильно)
	// тогда откуда max и min вообще? Ну min это наименьшее число ожидаемых дней, а max - максимальное
	// тебе задаче надо это вывода да
	// ок
	// сейчас посмотрю программу уббпалери управление мышкой я не могу дваигать я у
	// неправильно
	// ты идешь по массиву до скончания времен
	// надо идти по массиву a не до конца да, там надо break поставить
	// или использовать другой цикл
	// цикл for не для этого
	// смотри

	for (int i = 0; i < m; i++) {
		int j = 0;

		// while работает как цикл пока, то есть пока условие верно внутри скобок 
		// тут условие пока b[i] больше a[j] мы жолжны двигаться по a[j] ну по массиву a
		// то есть с первого элемента массива а мы идем по массиву пока не будет такое число a[j], что b[i] окажется меньше, чем a[j]. Все, понял
		// супер

		// равно, это чтобы пропускать ожинаковые значения, чтобы не было разницы в 0 понял? а, ну тогда скорее всего потому что последние значения были одинаковыми 9
		// 6 и 6)
		// да
		// надо делать проверку дополительнуб на это
		// понял? вроде максимум длины массива это m, значит j должна доходить до m - 1 поэтому когда j = m мы выходим
		// но сейчас все равно будет ошибка, почему? хз
		// смотри, ты сначала проверяешь в while на a[j] а потом только проверяешь на j < m, эти условия надо поменять местами
		// тогда по первому условию сразу мы выйдем и ошибки не будет, так как оператор && так работает, это логичское И, то есть если мы в самом начале получили false,
		// то есть 0, то что бы мы не умножали, получится 0, значит нет смысла что-то делать и ответ 0
		// понял? да супер
		// )))))
		// ща посморим многообещающе

		while (j < m && b[i] >= a[j]) { // понял почему ошибка? нет, ну ты равно зачем то поставила 
			j++;
		}

		if (j == m) {
			break;
		}

		// понятнр? да точно? ну тут сложно не понять хах ну лан
		// мне не оч нравится, что мы два раза это проверяем, надо как-то сделать лучше
		// лан, наверно ок
		// давац проверим
		// работает ур ой еще раз работает
		// пончл? ага, там кстати есть в самом задании примеры для ввода 
	    // чтобы самому не париться с нахождением ответа
		// они там не для этого)) а чтобы ты на примерах понял условие
		// давай ты введешь примеры и мы сравним
		// ты когда вводишь два числа в начале вот и ошибка
		// вводи их тоже через энтер ну что?удочлетворен
		// еще там есть примеры? Так это мой был)) а
		// ну крч работает
		// ты понял все? да отлично
		// смотри, сейчас мы это запушим в гитхаб, следующие задачи ты решишь на неделе и если сможешь, запушишь их в гитхаб и я буду их проверять на неделе напрмер или в субботу. ок? давай попробуем
		// я коммаентарии оставлю, чтобы ты потом если что перечитал и вспомнил что-то

		// сейчас a[j] - это первый день, больший, чем b[i], согласен? ну наверно что непонятно? пока что все), ща разберусь ты смотри только жо этого комманта
		// сейчас нужно просто сравнить разницу a[j] и b[i] с min и max

		// теперь проблема появилась с тем, что у тебя min = 0
		// никогла так не делай
		// у тебя min всегда должен быть оч большим числом
		// а мах наоборот очеень малееньким
		// это делается для первог сравнения
		// либо еще делают их начальные значения первыми значениям массива например, ну это иногда
		// тут тебе лучше задать большие и маленькие, потому что у тебя разница, тут начальные значения массива не подойдут

		// понял, где ошщибка? Ну вроде да, типо почему эта разница константа если она не константа
		// вообще нет)))
		// разница здесь может быть константой, потому что она каждый раз для внешнего цикла создается заново
		// и за одну итерацию циклв for я только один раз присваиваю ей значенние
		// ощибка как раз в j, мы вышли из цикла, когда j стало равно m, то есть когда мы хотим получить доступ к несуществующему элементу
		// а потом мы идем в diff и снова высчитываем разницу, а нам надо выйти

		const int diff = a[j] - b[i];
		if (min > diff) {
			min = diff;
		}
		else if (max < diff) {
			max = diff;
		}

		// понятно?
		// const if это типо константа?
	// const int только, да
		// ее нельзя измеенять
		// это необязаткльно, просто ты таким образом показываешь для других разработчиков что эту разницу в коде дальше не надо изменять
		// можно просто int написать
	}

	std::cout << min;
	std::cout << std::endl;
	std::cout << max;

	return 0;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
